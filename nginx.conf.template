log_format json_log escape=json
  '{'
    '"level":"info",'
    '"create_time":"$time_iso8601",'
    '"timestamp":"$msec",'
    '"remote_addr":"$remote_addr",'
    '"remote_user":"$remote_user",'
    '"x_forwarded_for":"$http_x_forwarded_for",'
    '"request_id":"$req_id",'
    '"trace_id":"$upstream_http_x_trace_id",'
    '"method":"$request_method",'
    '"uri":"$request_uri",'
    '"server_protocol":"$server_protocol",'
    '"status":$status,'
    '"bytes_sent":$bytes_sent,'
    '"body_bytes_sent":$body_bytes_sent,'
    '"request_time":"$request_time",'
    '"upstream_response_time":"$upstream_response_time",'
    '"referer":"$http_referer",'
    '"user_agent":"$http_user_agent",'
    '"host":"$host"'
  '}';

map $upstream_http_cache_control $cache_control_value {
    ""      "no-cache";
    default $upstream_http_cache_control;
}

# Rules for WeCom (Enterprise WeChat) crawling: User-Agent must contain "wxwork", URL must not include "wework_cfm_code", and Referer must be empty
map "$http_user_agent:$request_uri:$http_referer" $is_wxwork_crawler {
    default 0;
    ~*wxwork.*[^:]*:[^:]*[^wework_cfm_code][^:]*:[^:]*$ 1;
}

# Detect bot User-Agents (only match explicit bot identifiers, not in-app browsers)
map $http_user_agent $is_bot {
    default 0;

    ~*larkurl 1;                       # Lark
    ~*iframely/ 1;                     # Notion（Iframely-based）
    ~*dingtalkbot 1;                   # DingDing
    ~*wxwork  $is_wxwork_crawler;      # weChat Enterprise
    ~*wechatshareextensionnew 1;       # weChat
}

server {
    listen 80;

    server_name _;
    client_max_body_size 128M;

    set $req_id $http_x_request_id;
    if ($req_id = "") {
        set $req_id $request_id;
    }

    location /assets/ {
        root /usr/share/nginx/html;
        gzip_static on;
        gzip off;
        try_files $uri $uri/ =404;
        add_header Cache-Control "public, max-age=31536000, immutable";
        access_log off;
    }

    location ~ "^/s/([0-9A-Za-z]{10})(/([0-9A-Za-z]{16}))?$" {
        set $share_id $1;
        set $resource_id $3;

        # If bot detected, proxy to backend SEO module for dynamic HTML with meta tags
        if ($is_bot = 1) {
            proxy_pass ${BACKEND_OSS}/api/v1/seo/shares/$share_id/$resource_id;
            break;
        }

        # For regular users, serve SPA
        root /usr/share/nginx/html;
        try_files $uri /index.html;
        add_header Cache-Control "no-store, no-cache, must-revalidate";
        add_header Pragma "no-cache";
        add_header Expires 0;
    }

    location ~ "^/([0-9A-Za-z]{6})/([0-9A-Za-z]{16})$" {
        set $namespace_id $1;
        set $resource_id $2;

        # If bot detected, proxy to backend SEO module
        # Backend will check if enable_seo is true for this resource
        if ($is_bot = 1) {
            proxy_pass ${BACKEND_OSS}/api/v1/seo/namespaces/$namespace_id/resources/$resource_id;
            break;
        }

        # For regular users, serve SPA
        root /usr/share/nginx/html;
        try_files $uri /index.html;
        add_header Cache-Control "no-store, no-cache, must-revalidate";
        add_header Pragma "no-cache";
        add_header Expires 0;
    }

    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
        add_header Cache-Control "no-store, no-cache, must-revalidate";
        add_header Pragma "no-cache";
        add_header Expires 0;
    }

    location ~ ^/([^/]+)/([^/]+)/attachments/([^/]+)$ {
        rewrite ^/([^/]+)/([^/]+)/attachments/([^/]+)$ /api/v1/namespaces/$1/resources/$2/attachments/$3 last;
    }

    location ~ ^/s/([^/]+)/([^/]+)/attachments/([^/]+)$ {
        rewrite ^/s/([^/]+)/([^/]+)/attachments/([^/]+)$ /api/v1/shares/$1/resources/$2/attachments/$3 last;
    }

    location ~ ^/api/v1/socket.io {
        proxy_pass ${BACKEND_OSS};
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_cache off;
        proxy_buffering off;
        proxy_read_timeout 86400;
    }

    # Commercial module routes (pay, orders, products, feedback)
    location ~ ^/api/v1/(pay|orders|products|feedback) {
        proxy_pass ${BACKEND_PRO};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_set_header REMOTE-HOST $remote_addr;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $http_connection;
        proxy_http_version 1.1;
        add_header X-Cache $upstream_cache_status;

        proxy_hide_header Cache-Control;
        add_header Cache-Control $cache_control_value always;

        add_header X-Request-Id $req_id always;
        proxy_set_header X-Request-Id $req_id;

        proxy_cache off;
        proxy_buffering off;
        chunked_transfer_encoding on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 300;
    }

    # Open source module routes (all other APIs)
    location ~ ^/(open/)?api/ {
        proxy_pass ${BACKEND_OSS};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_set_header REMOTE-HOST $remote_addr;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $http_connection;
        proxy_http_version 1.1;
        add_header X-Cache $upstream_cache_status;

        proxy_hide_header Cache-Control;
        add_header Cache-Control $cache_control_value always;

        add_header X-Request-Id $req_id always;
        proxy_set_header X-Request-Id $req_id;

        proxy_cache off;
        proxy_buffering off;
        chunked_transfer_encoding on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 300;
    }

    access_log /var/log/nginx/access.log json_log;
    error_log /var/log/nginx/error.log warn;
}
